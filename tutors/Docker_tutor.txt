
Для начала можем удалить все прошлые версии докера на всякий случай:
sudo apt-get remove docker docker-engine docker.io conrainerd runc

После чего скачиваем докер с официального сайта:
curl -fsSL https://get.docker.com -o get-docker.sh  

Устанавливаем докер:
sudo sh get-docker.sh

Добавляем пользователя в группу докера
(дабы работать с образами и контейнерами без постоянного ввода sudo):
sudo usermod -aG docker $USER 
Стоит добавить, что изменения вступят в силу, только после logout.

Команды docker:
docker info - развёрнутая информаци о docker.
docker version - показывает версию docker engine. Вывод сведений о версиях клиента и сервера Docker.
docker --version - показывает версию docker.
docker login — вход в реестр Docker.
docker system prune — удаление неиспользуемых контейнеров, сетей и образов, которым не назначено имя и тег.
docker create - создает контейнер из выбранного образа.
docker start - активирует уже существующий контейнер.
docker restart - перезапуск контейнера.
docker run <название контейнера> - запуск контейнера из образа 
(если образ не присутствует локально, то докер спулит его с хоста).
docker run --name webapp <название контейнера> - запуск контейнера с присваиванием имени.
docker run -d <название контейнера> - запуск контейнера в фоновом режиме.
docker attach <название контейнера> - возврат состояния работающего контейнера 
к консоли.
docker run -i <название контейнера> - подключение к контейнеру в интерактивном режиме.
docker run -t <название контейнера> - использование псевдо-терминала.
docker ps - просмотр список запущенных контейнеров и информация о них.
docker ps -a - демонстрация всех контейнеров.
docker stop <название контейнера> - остановка работы работающего контейнера.
docker stop $(docker ps -q) - остановка всех активных контейнеров.
docker rm <название контейнера> - полностью удаляет остановленный контейнер.
docker rm $(docker ps -aq) - удаление всех неактивных контейнеров.
docker images - демонстрация всех локальных образов.
docker rmi <название образа> - удаление образа (контейнеры от образа, 
не должны быть запущены в системе, их нужно остановить и удалить).
docker pull <название образа> - скачивание образа из репозитория.
docker exec <название контейнера> - демонстрация файла внутри контейнера.
*прим* docker exec trusting_gates cat /etc/hosts (при запущенном nginx).
docker run -v /opt/datadir/:/var/lib/mysql mysql - таким образом мы неявно монтируем
и синхронизируем локальный образ нашей БД в БД докер файла и тем самым 
послеостановки контейнера все новый данные остануться и сохранятся у нас локально.
docker inspect - возвращает детальную картину нашего докер контейнера в 
JSON-формате, его состояние, что смонтировано, как сконфигурированно, настройка сети.
docker logs - просмотр логов нашего контейнера.
docker run -p 30123:8080 rotorocloud/simple-webapp-rockets:v2 - Запуск контейнера
rotorocloud/simple-webapp-rockets с тегом v2, сопоставляя порт 8080 контейнера 
порту 30123 хоста.

sudo systemctl status docker - проверка статуса службы docker на хосте.
docker history <название образа> - демонстрация слоёв исполняемых команд док-образа.
docker build . - создание docker-образа из Dockerfile в текущей директории.
docker build -f  <путь к директории> - создание из удалённой директории. 
docker tag <image id> <название образа>:<тег образа> - с помощью данной процедуры
мы можем именовать и переименовывать наши образы, особенно актуально это решение
для только что созданных безымянных образов.
docker login - процедура для авторизации на docker hub.
docker push <название образа> - пушим образ в облачный репозиторий на docker hub
(стоит добавить, что после отправки, наш образ в репозитории будет храниться
в сжатом виде).

rocket = os.environ.get("ROCKET_SIZE")
> export ROCKET_SIZE=big; python3 app.py - с помощью данной команды, мы можем
влиять на предназначенную для этого переменную в нашем коде, не меняя сам код.
Можно сказать, что такой подход является хорошим паттерном кодинга, позволяя
нам не собирать разные билды под каждый размер "рокеты".
Однако если мы попробуем после этого запустить наш контейнер, но ничего не поменяется.
> docker run -e ROCKET_SIZE=small <название образа>

docker run -e ROCKET_SIZE=big -p 30888:8080 --name rocket-app rotorocloud/simple-webapp-rockets

--------------------------Docerfile---------------------------------

Команды в Dockerfile:
FROM - какой образ мы берём для начала за основу.
RUN — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
CMD - указываем программу или команду, которая будет запущена в контейнере,
а также все дополнительные аргументы, которые ты бы указал в командной строке.
ENTRYPOINT - указываем программу или команду, которая будет запущена в контейнере,
а также все дополнительные аргументы, которые ты бы указал в командной строке.
Основное отличие двух вышеперечисленных команд, что в случае импользования команды
 - CMD переданные параметры будут полностью заменены.
 - ENTRYPOINT переданные параметры будут добавлены.
Стоит добавить, что их можно сочетать, но указывать их параметры нужно всегда в
формате JSON.
LABEL — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
ENV — устанавливает постоянные переменные среды.
COPY — копирует в контейнер файлы и папки.
ADD — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
WORKDIR — задаёт рабочую директорию для следующей инструкции.
ARG — задаёт переменные для передачи Docker во время сборки образа.
EXPOSE — указывает на необходимость открыть порт.
VOLUME — создаёт точку монтирования для работы с постоянным хранилищем.

'''
ENTRYPOINT ["sleep"]
CMD ["5"]
'''
docker run --entrypoint - команда которую мы используем, 
если хотим изменить параметр ENTRYPOINT.

'''
FROM ubuntu

RUN apt-get update
    
RUN apt-get install -y python3 python3-pip
    
RUN pip3 install flask --break-system-packages
   
COPY app.py /opt/app.py

ENTRYPOINT FLASK_APP=/opt/app.py flask run --host=0.0.0.0 --port=5000
'''

----------------------DOCKER COMPOSE-------------------------------

*Пример файла*
docker-compose.yml >>
'''
# version: 1
redis:				# Название контейнера. 
	image: redis		# Из какого образа мы его берём. Ключ - это будущий контейнер, азначение - имя образа, 
				# / которое будет в нем использоваться
	# build: /home/user/docker_yml_files # Если данного образа нет даже в облачном репозитерии, то мы можем собрать 
					     # / его сами заранее записав инструкции по его сборке в Dockerfile. 
db:
	image: postgres:9.4
vote:
	images: voting-app
	ports:			# Перечесление портов.
	- 5000:80 		# Это приложение веб-сервер, слушает на http порту (#80), мы опубликуем его в хост-системе под
				# / номером 5000. Таким образом трафик полученный на порт 5000 нашей хост-системы будет передан
				# / на порт 80 контейнера vote, этим мы сделаем его доступным из браузера.
	links:			# Перечесления ссылок для взаимодействия сервисов.
	- redis			# Вносит статическую запись в /etc/hosts контейнера vote с привязкой имени redis к текущему 
				# / внутреннему IP контейнера redis.
result:
	image: result-app
	ports:
	- 5001:80
	links:
	- db
worker:
	image: worker
	links: 			# Ссылаемся сразу на два серивиса, берём данные в redis и отправляем их в db.
	- db
	- redis
'''

Команды docker-compose:
docker-compose up -d - Разворачивает стек из файла docker-compose.yml текущей директории.
docker-compose down - Останавливает стек и удаляет все контейнеры и сети.
docker-compose ps - Покажет контейнеры, за которые Docker Compose несет ответственность.
docker-compose logs - Общий пул логов поднятого стека Docker Compose.
docker-compose up --scale vote=3 - Управление количеством реплик определенной службы.


docker-compose.yml >>
'''
version: 2			# Указание версии файла. В данном случае цифра 2, скажет docker-compose объяденить контейнеры
				# / в единую мостовую сеть.
services:			# Параметр linls со второй версии уже не обязателен, т.к. контейнеры связываются друг с другом, 
				# / используя имена заданные под параметром services.
	redis:
		image: redis
		networks:
		- backend:
	db:
		image: postgres:9.4
		networks:
		- backend:
	vote:
		image: voting-app
		ports:
		-	5000:80
		depends_on:	# Т.к. приложение для голосования зависит от службы redis, здесь мы явно указываем, что контейнер 
				# / redis запуститься первым, а уже после приложение для голосования.  
		-	redis
		networks:
		- frontend:
		- backend:
	result:
		image: result-app
		networks:
		- frontend:
		- backend:
networks:			# Указываем какие именно сети мы собираемся использовать в данном развёртовании, 
				# / (у нас есть две, внешняя и внутреняя). Содзаём новое свойство "networks" на уровне yml-документа, 
				# / размещая в нём нашу карту сетей, которую мы будем искользовать во всех объявленных службах.
				# После чего их нужно явно объявить в наших службах.
	frontend:
	backend:
'''

------------------------------Хранение в Docker------------------------------------------

Способы взаимодействия с docker на удалённых хостах:
docker -H=remote-docker-engine:2375
docker -H=10.10.10.1:2375 run nginx

docker run --cpus-.5 nginx - это ограничивает docker одномоментно использовать не более 50% вычислительной мощности хоста.
docker run --memory=100m nginx - ограничение использования оперативной памяти контейнером в 100Мб.



--------------------Создание проекта с Docker and Docker compose----------------------------

Команды в Linux
10389* docker-compose build - билдим без проекта (успешно)
10393* docker-compose up - поднимаем (безуспешно, т.к. нет проекта с manage.py)
Добавляем проект
10394* docker-compose run --rm web-app sh -c "django-admin startproject service ."
* --rm - удаление контейнера после выполненая задачи
* web-app - имя сервиса из которого мы должны создать контейнер
* sh -c - далее в кавычках будет команда, которая должна запускаться из Linux shell
* --rm - удаление контейнера после выполненая задачи
Снова поднимаем
10395* docker-compose up


requirements.txt
Django==3.2.16
djangorestframework==3.14.0


Dockerfile
# Основа для нашего имаджа.
FROM python:3.9-alpine3.16
# Копируем наш файл с зависимостями.
COPY requirements.txt /temp/requirements.txt
# Копируем директорию с нашим приложением.
COPY service /service
# Рабочая директория в которой будут запускаться команды, которые мы передаём внутри контейнера.
WORKDIR /service
# Открываем порт.
EXPOSE 8000
# Устанавливаем зависимости.
RUN pip install -r /temp/requirements.txt
# Создаст пользователя в операционной системе ()без пароля).
RUN adduser --disabled-password service-user
# Пользователь под которым мы будем запускать все программы.
USER service-user


docker-compose.yml
version: "3"
services:
  # Название нашего сервиса (приложения).
  web-app:
    # Путь к месту Dockerfile для билда нашего имаджа.
    build:
      context: .
    # Проброска портов из докер контейнера в наше ОС.
    # Порт в контейнера : порт в нашей ОС
    ports:
      - "8000:8000"
    # Подключенные тома.
    volumes:
      - ./service:/service

    command: >
      sh -c "python3 manage.py runserver 0.0.0.0:8000"





























