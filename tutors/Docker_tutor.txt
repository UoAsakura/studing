
Для начала можем удалить все прошлые версии докера на всякий случай:
sudo apt-get remove docker docker-engine docker.io conrainerd runc

После чего скачиваем докер с официального сайта:
curl -fsSL https://get.docker.com -o get-docker.sh  

Устанавливаем докер:
sudo sh get-docker.sh

Добавляем пользователя в группу докера
(дабы работать с образами и контейнерами без постоянного ввода sudo):
sudo usermod -aG docker $USER 
Стоит добавить, что изменения вступят в силу, только после logout.

Команды docker:
docker run <название контейнера> - запуск контейнера из образа 
(если образ не присутствует локально, то докер спулит его с хоста).
docker run --name webapp <название контейнера> - запуск контейнера с присваиванием имени.
docker run -d <название контейнера> - запуск контейнера в фоновом режиме.
docker attach <название контейнера> - возврат состояния работающего контейнера 
к консоли.
docker run -i <название контейнера> - подключение к контейнеру в интерактивном режиме.
docker run -t <название контейнера> - использование псевдо-терминала.
docker ps - просмотр список запущенных контейнеров и информация о них.
docker ps -a - демонстрация всех контейнеров.
docker stop <название контейнера> - остановка работы работающего контейнера.
docker stop $(docker ps -q) - остановка всех активных контейнеров.
docker rm <название контейнера> - полностью удаляет остановленный контейнер.
docker rm $(docker ps -aq) - удаление всех неактивных контейнеров.
docker images - демонстрация всех локальных образов.
docker rmi <название образа> - удаление образа (контейнеры от образа, 
не должны быть запущены в системе, их нужно остановить и удалить).
docker pull <название образа> - скачивание образа из репозитория.
docker exec <название контейнера> - демонстрация файла внутри контейнера.
*прим* docker exec trusting_gates cat /etc/hosts (при запущенном nginx).
docker run -v /opt/datadir/:/var/lib/mysql mysql - таким образом мы неявно монтируем
и синхронизируем локальный образ нашей БД в БД докер файла и тем самым 
послеостановки контейнера все новый данные остануться и сохранятся у нас локально.
docker inspect - возвращает детальную картину нашего докер контейнера в 
JSON-формате, его состояние, что смонтировано, как сконфигурированно, настройка сети.
docker logs - просмотр логов нашего контейнера.
docker run -p 30123:8080 rotorocloud/simple-webapp-rockets:v2 - Запуск контейнера
rotorocloud/simple-webapp-rockets с тегом v2, сопоставляя порт 8080 контейнера 
порту 30123 хоста.

sudo systemctl status docker - проверка статуса службы docker на хосте.
docker history <название образа> - демонстрация слоёв исполняемых команд док-образа.
docker build . - создание docker-образа из Dockerfile.
docker tag <image id> <название образа>:<тег образа> - с помощью данной процедуры
мы можем именовать и переименовывать наши образы, особенно актуально это решение
для только что созданных безымянных образов.
docker login - процедура для авторизации на docker hub.
docker push <название образа> - пушим образ в облачный репозиторий на docker hub
(стоит добавить, что после отправки, наш образ в репозитории будет храниться
в сжатом виде).

rocket = os.environ.get("ROCKET_SIZE")
> export ROCKET_SIZE=big; python3 app.py - с помощью данной команды, мы можем
влиять на предназначенную для этого переменную в нашем коде, не меняя сам код.
Можно сказать, что такой подход является хорошим паттерном кодинга, позволяя
нам не собирать разные билды под каждый размер "рокеты".
Однако если мы попробуем после этого запустить наш контейнер, но ничего не поменяется.
> docker run -e ROCKET_SIZE=small <название образа>

docker run -e ROCKET_SIZE=big -p 30888:8080 --name rocket-app rotorocloud/simple-webapp-rockets


Команды в Dockerfile:
FROM - какой образ мы берём для начала за основу.
RUN - выполнение команды.
CMD - указываем программу или команду, которая будет запущена в контейнере,
а также все дополнительные аргументы, которые ты бы указал в командной строке.
ENTRYPOINT - указываем программу или команду, которая будет запущена в контейнере,
а также все дополнительные аргументы, которые ты бы указал в командной строке.
Основное отличие двух вышеперечисленных команд, что в случае импользования команды
 - CMD переданные параметры будут полностью заменены.
 - ENTRYPOINT переданные параметры будут добавлены.
Стоит добавить, что их можно сочетать, но указывать их параметры нужно всегда в
формате JSON.
'''
ENTRYPOINT ["sleep"]
CMD ["5"]
'''
docker run --entrypoint - команда которую мы используем, 
если хотим изменить параметр ENTRYPOINT.

'''
FROM ubuntu

RUN apt-get update
    
RUN apt-get install -y python3 python3-pip
    
RUN pip3 install flask --break-system-packages
   
COPY app.py /opt/app.py

ENTRYPOINT FLASK_APP=/opt/app.py flask run --host=0.0.0.0 --port=5000
'''



----------------------DOCKER COMPOSE-------------------------------

*Пример файла*
docker-compose.yml >>
'''
# version: 1
redis:				# Название контейнера. 
	image: redis		# Из какого образа мы его берём. Ключ - это будущий контейнер, азначение - имя образа, 
				# / которое будет в нем использоваться
	# build: /home/user/docker_yml_files # Если данного образа нет даже в облачном репозитерии, то мы можем собрать 
					     # / его сами заранее записав инструкции по его сборке в Dockerfile. 
db:
	image: postgres:9.4
vote:
	images: voting-app
	ports:			# Перечесление портов.
	- 5000:80 		# Это приложение веб-сервер, слушает на http порту (#80), мы опубликуем его в хост-системе под
				# / номером 5000. Таким образом трафик полученный на порт 5000 нашей хост-системы будет передан
				# / на порт 80 контейнера vote, этим мы сделаем его доступным из браузера.
	links:			# Перечесления ссылок для взаимодействия сервисов.
	- redis			# Вносит статическую запись в /etc/hosts контейнера vote с привязкой имени redis к текущему 
				# / внутреннему IP контейнера redis.
result:
	image: result-app
	ports:
	- 5001:80
	links:
	- db
worker:
	image: worker
	links: 			# Ссылаемся сразу на два серивиса, берём данные в redis и отправляем их в db.
	- db
	- redis
'''

Команды docker-compose:
docker-compose up -d - Разворачивает стек из файла docker-compose.yml текущей директории.
docker-compose down - Останавливает стек и удаляет все контейнеры и сети.
docker-compose ps - Покажет контейнеры, за которые Docker Compose несет ответственность.
docker-compose logs - Общий пул логов поднятого стека Docker Compose.
docker-compose up --scale vote=3 - Управление количеством реплик определенной службы.


docker-compose.yml >>
'''
version: 2			# Указание версии файла. В данном случае цифра 2, скажет docker-compose объяденить контейнеры
				# / в единую мостовую сеть.
services:			# Параметр linls со второй версии уже не обязателен, т.к. контейнеры связываются друг с другом, 
				# / используя имена заданные под параметром services.
	redis:
		image: redis
		nwtworks:
		- backend:
	db:
		image: postgres:9.4
		nwtworks:
		- backend:
	vote:
		image: voting-app
		ports:
		-	5000:80
		depends_on:	# Т.к. приложение для голосования зависит от службы redis, здесь мы явно указываем, что контейнер 
				# / redis запуститься первым, а уже после приложение для голосования.  
		-	redis
		nwtworks:
		- frontend:
		- backend:
	result:
		image: result-app
		nwtworks:
		- frontend:
		- backend:
nwtworks:			# Указываем какие именно сети мы собираемся использовать в данном развёртовании, 
				# / (у нас есть две, внешняя и внутреняя). Содзаём новое свойство "networks" на уровне yml-документа, 
				# / размещая в нём нашу карту сетей, которую мы будем искользовать во всех объявленных службах.
				# После чего их нужно явно объявить в наших службах.
	frontend:
	backend:
'''

------------------------------Хранение в Docker------------------------------------------
Способы взаимодействия с docker на удалённых хостах:
docker -H=remote-docker-engine:2375
docker -H=10.10.10.1:2375 run nginx







































